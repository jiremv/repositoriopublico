"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _DirectlyTransferable_value, _ArrayBufferViewTransferable_view, _Piscina_pool;
const worker_threads_1 = require("worker_threads");
const events_1 = require("events");
const eventemitter_asyncresource_1 = __importDefault(require("eventemitter-asyncresource"));
const async_hooks_1 = require("async_hooks");
const os_1 = require("os");
const url_1 = require("url");
const path_1 = require("path");
const util_1 = require("util");
const assert_1 = __importDefault(require("assert"));
const hdr_histogram_js_1 = require("hdr-histogram-js");
const perf_hooks_1 = require("perf_hooks");
const hdr_histogram_percentiles_obj_1 = __importDefault(require("hdr-histogram-percentiles-obj"));
const common_1 = require("./common");
const package_json_1 = require("../package.json");
const cpuCount = (() => {
    try {
        return os_1.cpus().length;
    }
    catch {
        /* istanbul ignore next */
        return 1;
    }
})();
;
function onabort(abortSignal, listener) {
    if ('addEventListener' in abortSignal) {
        abortSignal.addEventListener('abort', listener, { once: true });
    }
    else {
        abortSignal.once('abort', listener);
    }
}
class AbortError extends Error {
    constructor() {
        super('The task has been aborted');
    }
    get name() { return 'AbortError'; }
}
class ArrayTaskQueue {
    constructor() {
        this.tasks = [];
    }
    get size() { return this.tasks.length; }
    shift() {
        return this.tasks.shift();
    }
    push(task) {
        this.tasks.push(task);
    }
    remove(task) {
        const index = this.tasks.indexOf(task);
        assert_1.default.notStrictEqual(index, -1);
        this.tasks.splice(index, 1);
    }
}
const kDefaultOptions = {
    filename: null,
    name: 'default',
    minThreads: Math.max(cpuCount / 2, 1),
    maxThreads: cpuCount * 1.5,
    idleTimeout: 0,
    maxQueue: Infinity,
    concurrentTasksPerWorker: 1,
    useAtomics: true,
    taskQueue: new ArrayTaskQueue(),
    niceIncrement: 0,
    trackUnmanagedFds: true
};
const kDefaultRunOptions = {
    transferList: undefined,
    filename: null,
    signal: null,
    name: null
};
c